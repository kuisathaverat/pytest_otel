# Beast AI Agent - Code Quality and Best Practices

This agent provides comprehensive guidance on software engineering principles, Python best practices, documentation standards, and markdown formatting.

## Core Software Engineering Principles

### KISS - Keep It Simple, Stupid

**Philosophy**: Simplicity should be a key goal in design, and unnecessary complexity should be avoided.

**Guidelines**:
- Write code that is easy to understand and maintain
- Avoid over-engineering solutions
- Choose straightforward approaches over clever tricks
- Break complex problems into smaller, manageable pieces
- If you can't explain it simply, you don't understand it well enough
- Prefer readable code over concise but cryptic code
- Use clear naming conventions that convey intent
- Minimize the number of moving parts in your solution

**Example**:
```python
# Good - Simple and clear
def calculate_total_price(items):
    return sum(item.price for item in items)

# Bad - Unnecessarily complex
def calculate_total_price(items):
    return functools.reduce(lambda acc, item: acc + item.price, items, 0)
```

### SOLID Principles

#### S - Single Responsibility Principle (SRP)
**Definition**: A class should have only one reason to change.

**Guidelines**:
- Each class should focus on doing one thing well
- If a class has multiple responsibilities, split it into separate classes
- Changes to one aspect shouldn't require modifying unrelated functionality
- Ask: "What is the single responsibility of this class?"

**Example**:
```python
# Good - Single responsibility
class UserRepository:
    def save_user(self, user):
        # Only handles database operations
        pass

class UserValidator:
    def validate_user(self, user):
        # Only handles validation
        pass

# Bad - Multiple responsibilities
class User:
    def save(self):
        pass
    def validate(self):
        pass
    def send_email(self):
        pass
```

#### O - Open/Closed Principle (OCP)
**Definition**: Software entities should be open for extension but closed for modification.

**Guidelines**:
- Design systems that can be extended without modifying existing code
- Use inheritance, interfaces, and composition
- Avoid modifying existing classes when adding new features
- Use abstract base classes and protocols in Python

**Example**:
```python
# Good - Open for extension
from abc import ABC, abstractmethod

class PaymentProcessor(ABC):
    @abstractmethod
    def process_payment(self, amount):
        pass

class CreditCardProcessor(PaymentProcessor):
    def process_payment(self, amount):
        # Credit card logic
        pass

class PayPalProcessor(PaymentProcessor):
    def process_payment(self, amount):
        # PayPal logic
        pass

# Bad - Requires modification for new payment types
class PaymentProcessor:
    def process_payment(self, payment_type, amount):
        if payment_type == "credit_card":
            # Credit card logic
            pass
        elif payment_type == "paypal":
            # PayPal logic
            pass
```

#### L - Liskov Substitution Principle (LSP)
**Definition**: Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.

**Guidelines**:
- Derived classes must be substitutable for their base classes
- Don't strengthen preconditions or weaken postconditions
- Preserve the expected behavior of the base class
- Avoid violating the contract established by the parent class

**Example**:
```python
# Good - Proper substitution
class Bird(ABC):
    @abstractmethod
    def move(self):
        pass

class Sparrow(Bird):
    def move(self):
        return "flying"

class Penguin(Bird):
    def move(self):
        return "walking"

# Bad - Violates LSP
class Bird:
    def fly(self):
        return "flying"

class Penguin(Bird):
    def fly(self):
        raise NotImplementedError("Penguins can't fly")
```

#### I - Interface Segregation Principle (ISP)
**Definition**: Clients should not be forced to depend on interfaces they don't use.

**Guidelines**:
- Create specific, focused interfaces rather than large, general-purpose ones
- Split large interfaces into smaller, more specific ones
- Classes should only implement methods they actually need
- Use Python's Protocol or ABC for defining interfaces

**Example**:
```python
# Good - Segregated interfaces
class Printable(Protocol):
    def print(self): ...

class Scannable(Protocol):
    def scan(self): ...

class Printer:
    def print(self):
        pass

class Scanner:
    def scan(self):
        pass

class MultiFunctionDevice:
    def print(self):
        pass
    def scan(self):
        pass

# Bad - Fat interface
class Machine(ABC):
    @abstractmethod
    def print(self): pass
    
    @abstractmethod
    def scan(self): pass
    
    @abstractmethod
    def fax(self): pass

class SimplePrinter(Machine):
    def print(self):
        pass
    
    def scan(self):
        raise NotImplementedError()
    
    def fax(self):
        raise NotImplementedError()
```

#### D - Dependency Inversion Principle (DIP)
**Definition**: High-level modules should not depend on low-level modules. Both should depend on abstractions.

**Guidelines**:
- Depend on abstractions, not concrete implementations
- Use dependency injection
- Define interfaces/protocols for dependencies
- Invert the direction of dependencies toward abstractions

**Example**:
```python
# Good - Depends on abstraction
class MessageSender(ABC):
    @abstractmethod
    def send(self, message):
        pass

class EmailSender(MessageSender):
    def send(self, message):
        # Email implementation
        pass

class NotificationService:
    def __init__(self, sender: MessageSender):
        self.sender = sender
    
    def notify(self, message):
        self.sender.send(message)

# Bad - Depends on concrete implementation
class NotificationService:
    def __init__(self):
        self.email_sender = EmailSender()
    
    def notify(self, message):
        self.email_sender.send(message)
```

### DRY - Don't Repeat Yourself

**Philosophy**: Every piece of knowledge should have a single, unambiguous representation within a system.

**Guidelines**:
- Avoid code duplication
- Extract common functionality into reusable functions or classes
- Use inheritance, composition, and mixins appropriately
- Create utility functions for repeated logic
- Don't duplicate business logic
- Be cautious: sometimes duplication is better than the wrong abstraction

**Example**:
```python
# Good - DRY
def validate_email(email):
    return "@" in email and "." in email

def register_user(email):
    if not validate_email(email):
        raise ValueError("Invalid email")
    # Registration logic

def update_user_email(user, email):
    if not validate_email(email):
        raise ValueError("Invalid email")
    # Update logic

# Bad - Repetition
def register_user(email):
    if not ("@" in email and "." in email):
        raise ValueError("Invalid email")
    # Registration logic

def update_user_email(user, email):
    if not ("@" in email and "." in email):
        raise ValueError("Invalid email")
    # Update logic
```

### YAGNI - You Aren't Gonna Need It

**Philosophy**: Don't add functionality until it's necessary.

**Guidelines**:
- Implement features only when they're actually needed
- Avoid building "future-proof" systems with unused features
- Focus on current requirements, not hypothetical future needs
- Refactor when new requirements emerge, don't anticipate them
- Keep the codebase lean and maintainable
- Premature optimization and abstraction are forms of YAGNI violation

**Example**:
```python
# Good - Only what's needed now
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

# Bad - Anticipating future needs
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
        self.address = None  # Not needed yet
        self.phone = None  # Not needed yet
        self.preferences = {}  # Not needed yet
        self.metadata = {}  # Not needed yet
```

### TDA - Tell, Don't Ask

**Philosophy**: Tell objects what to do, don't ask them for their state and make decisions based on that.

**Guidelines**:
- Encapsulate behavior within objects
- Minimize exposure of internal state
- Objects should make decisions based on their own data
- Avoid getter methods that expose internal state just for external decisions
- Push behavior into the object that owns the data

**Example**:
```python
# Good - Tell, Don't Ask
class ShoppingCart:
    def __init__(self):
        self.items = []
    
    def add_item(self, item):
        self.items.append(item)
    
    def apply_discount(self):
        if len(self.items) > 5:
            return sum(item.price for item in self.items) * 0.9
        return sum(item.price for item in self.items)

cart = ShoppingCart()
total = cart.apply_discount()

# Bad - Ask, Then Tell
class ShoppingCart:
    def __init__(self):
        self.items = []
    
    def get_items(self):
        return self.items

cart = ShoppingCart()
# External code asking for state and making decisions
if len(cart.get_items()) > 5:
    total = sum(item.price for item in cart.get_items()) * 0.9
else:
    total = sum(item.price for item in cart.get_items())
```

## Python Best Practices

### Code Style and Structure

**PEP 8 Compliance**:
- Follow PEP 8 style guide for Python code
- Use 4 spaces for indentation (never tabs)
- Limit lines to 79-120 characters (project-dependent)
- Use snake_case for functions and variables
- Use PascalCase for class names
- Use UPPER_CASE for constants

**Naming Conventions**:
```python
# Good naming
class UserAccount:
    MAX_LOGIN_ATTEMPTS = 3
    
    def __init__(self, username):
        self.username = username
        self._login_attempts = 0
    
    def authenticate_user(self, password):
        pass

# Bad naming
class userAccount:
    maxLoginAttempts = 3
    
    def __init__(self, u):
        self.u = u
        self.la = 0
    
    def auth(self, p):
        pass
```

### Type Hints

**Always use type hints** for function signatures and class attributes:

```python
from typing import List, Dict, Optional, Union

def process_users(users: List[str], config: Dict[str, any]) -> List[Dict[str, str]]:
    """Process a list of users based on configuration."""
    results: List[Dict[str, str]] = []
    for user in users:
        results.append({"name": user, "status": "processed"})
    return results

class User:
    def __init__(self, name: str, age: int, email: Optional[str] = None) -> None:
        self.name: str = name
        self.age: int = age
        self.email: Optional[str] = email
```

### Docstrings

**Use comprehensive docstrings** following PEP 257:

```python
def calculate_statistics(data: List[float]) -> Dict[str, float]:
    """
    Calculate basic statistics for a dataset.
    
    Args:
        data: A list of numerical values to analyze.
    
    Returns:
        A dictionary containing:
            - mean: The average of the values
            - median: The middle value
            - std_dev: The standard deviation
    
    Raises:
        ValueError: If the data list is empty.
    
    Example:
        >>> calculate_statistics([1, 2, 3, 4, 5])
        {'mean': 3.0, 'median': 3.0, 'std_dev': 1.41}
    """
    if not data:
        raise ValueError("Data list cannot be empty")
    
    # Implementation
    pass
```

### Error Handling

**Proper exception handling**:

```python
# Good - Specific exceptions
def read_config(file_path: str) -> Dict[str, any]:
    try:
        with open(file_path, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error(f"Config file not found: {file_path}")
        raise
    except json.JSONDecodeError as e:
        logger.error(f"Invalid JSON in config file: {e}")
        raise ValueError(f"Invalid configuration format") from e

# Bad - Bare except
def read_config(file_path):
    try:
        with open(file_path, 'r') as f:
            return json.load(f)
    except:
        return {}
```

### Context Managers

**Use context managers** for resource management:

```python
# Good - Automatic resource cleanup
with open('file.txt', 'r') as f:
    content = f.read()

# Custom context manager
from contextlib import contextmanager

@contextmanager
def database_connection(db_url: str):
    conn = create_connection(db_url)
    try:
        yield conn
    finally:
        conn.close()

with database_connection('postgresql://...') as conn:
    conn.execute("SELECT * FROM users")
```

### List Comprehensions and Generators

**Use comprehensions** for concise, readable code:

```python
# Good - List comprehension
squared_evens = [x**2 for x in range(10) if x % 2 == 0]

# Good - Generator for large datasets
def process_large_file(filename: str):
    with open(filename) as f:
        for line in f:
            yield process_line(line)

# Bad - Verbose loop
squared_evens = []
for x in range(10):
    if x % 2 == 0:
        squared_evens.append(x**2)
```

### Properties and Descriptors

**Use properties** for computed attributes:

```python
class Circle:
    def __init__(self, radius: float):
        self._radius = radius
    
    @property
    def radius(self) -> float:
        return self._radius
    
    @radius.setter
    def radius(self, value: float) -> None:
        if value < 0:
            raise ValueError("Radius cannot be negative")
        self._radius = value
    
    @property
    def area(self) -> float:
        return 3.14159 * self._radius ** 2
```

### Dataclasses

**Use dataclasses** for simple data structures:

```python
from dataclasses import dataclass, field
from typing import List

@dataclass
class User:
    name: str
    email: str
    age: int
    roles: List[str] = field(default_factory=list)
    
    def __post_init__(self):
        if self.age < 0:
            raise ValueError("Age cannot be negative")
```

### Testing Best Practices

**Write comprehensive tests**:

```python
import pytest
from typing import List

def test_user_creation():
    """Test that a user can be created with valid data."""
    user = User(name="John Doe", email="john@example.com", age=30)
    assert user.name == "John Doe"
    assert user.email == "john@example.com"

def test_user_invalid_age():
    """Test that user creation fails with invalid age."""
    with pytest.raises(ValueError, match="Age cannot be negative"):
        User(name="John Doe", email="john@example.com", age=-5)

@pytest.fixture
def sample_users() -> List[User]:
    """Fixture providing sample users for testing."""
    return [
        User(name="Alice", email="alice@example.com", age=25),
        User(name="Bob", email="bob@example.com", age=30),
    ]

def test_process_users(sample_users):
    """Test user processing with fixture data."""
    results = process_users(sample_users)
    assert len(results) == 2
```

### Modern Python Features

**Use modern Python features** (Python 3.10+):

```python
# Pattern matching (Python 3.10+)
def process_command(command: Dict[str, any]) -> str:
    match command:
        case {"action": "create", "resource": resource}:
            return f"Creating {resource}"
        case {"action": "delete", "resource": resource}:
            return f"Deleting {resource}"
        case _:
            return "Unknown command"

# Union types (Python 3.10+)
def process_value(value: int | str | None) -> str:
    if value is None:
        return "No value"
    return str(value)
```

### Logging

**Use proper logging** instead of print statements:

```python
import logging

logger = logging.getLogger(__name__)

def process_data(data: List[Dict[str, any]]) -> None:
    logger.info(f"Processing {len(data)} records")
    
    for record in data:
        try:
            process_record(record)
            logger.debug(f"Processed record: {record['id']}")
        except Exception as e:
            logger.error(f"Failed to process record {record['id']}: {e}", exc_info=True)
    
    logger.info("Processing completed")
```

## Documentation Principles

Based on the principles from "Principles of Technical Documentation" (https://www.innoq.com/en/articles/2022/01/principles-of-technical-documentation/):

### 1. Documentation as Code

**Treat documentation like code**:
- Store documentation in version control alongside code
- Review documentation changes through pull requests
- Automate documentation builds and deployments
- Keep documentation close to the code it describes
- Use the same quality standards for docs as for code

**Example structure**:
```
project/
├── src/
├── docs/
│   ├── architecture/
│   ├── api/
│   ├── guides/
│   └── README.md
├── README.md
└── CONTRIBUTING.md
```

### 2. Write for Your Audience

**Know your readers**:
- Identify who will read your documentation (developers, users, operators)
- Adjust technical depth accordingly
- Provide different documentation types for different audiences
- Use appropriate language and terminology
- Include examples relevant to your audience

**Example**:
```markdown
## For Developers

### Setting Up Development Environment

1. Clone the repository: `git clone ...`
2. Install dependencies: `pip install -r requirements.txt`
3. Run tests: `pytest`

## For Users

### Installation

Install the package using pip:
```bash
pip install pytest-otel
```
```

### 3. Keep It Current

**Maintain documentation freshness**:
- Update documentation with code changes in the same PR
- Regular documentation reviews and updates
- Mark deprecated features clearly
- Remove outdated information
- Use automated checks for broken links and examples

### 4. Structure and Organization

**Organize documentation logically**:
- Start with a clear overview and purpose
- Use hierarchical structure
- Provide navigation aids (table of contents, cross-references)
- Group related information together
- Use consistent formatting and templates

**Example structure**:
```markdown
# Component Name

## Overview
Brief description of what this component does.

## Installation
How to install or set up the component.

## Quick Start
Minimal example to get started quickly.

## Usage
Detailed usage instructions with examples.

## API Reference
Detailed API documentation.

## Troubleshooting
Common issues and solutions.

## Contributing
How to contribute to this component.
```

### 5. Include Examples

**Provide practical examples**:
- Show real-world usage scenarios
- Include both simple and complex examples
- Make examples runnable and testable
- Show common patterns and best practices
- Include expected output

### 6. Explain the Why

**Don't just describe what, explain why**:
- Explain design decisions and trade-offs
- Document the reasoning behind choices
- Provide context and background
- Explain when to use different approaches
- Include limitations and constraints

**Example**:
```python
class ConnectionPool:
    """
    Manages a pool of database connections.
    
    Why use a connection pool?
    - Reduces connection overhead (connections are expensive to create)
    - Limits concurrent connections (prevents overwhelming the database)
    - Improves performance through connection reuse
    
    Trade-offs:
    - Memory overhead: Maintains connections even when idle
    - Complexity: Requires proper connection lifecycle management
    
    When to use:
    - Applications with frequent database access
    - High-concurrency scenarios
    
    When not to use:
    - Simple scripts with infrequent database access
    - Single-threaded applications with sequential access
    """
```

### 7. Make It Discoverable

**Ensure documentation is easy to find**:
- Use clear, descriptive titles
- Implement search functionality
- Provide good navigation
- Link related documentation
- Use consistent naming conventions

### 8. Use Diagrams and Visuals

**Visualize complex concepts**:
- Architecture diagrams for system structure
- Sequence diagrams for workflows
- Flow charts for decision logic
- Screenshots for UI documentation
- Tables for comparing options

## Markdown Document Guidelines

### Structure and Formatting

**Headers**:
```markdown
# H1 - Document Title (use only once per document)

## H2 - Main Sections

### H3 - Subsections

#### H4 - Sub-subsections (use sparingly)
```

**Emphasis**:
```markdown
*italic* or _italic_
**bold** or __bold__
***bold and italic***
~~strikethrough~~
`inline code`
```

**Lists**:
```markdown
Unordered list:
- Item 1
- Item 2
  - Nested item 2.1
  - Nested item 2.2
- Item 3

Ordered list:
1. First item
2. Second item
   1. Nested item 2.1
   2. Nested item 2.2
3. Third item
```

**Links**:
```markdown
[Link text](https://example.com)
[Link with title](https://example.com "Title text")
[Reference-style link][reference]

[reference]: https://example.com
```

**Images**:
```markdown
![Alt text](path/to/image.png)
![Alt text](path/to/image.png "Image title")
```

**Code Blocks**:
````markdown
```python
def hello_world():
    print("Hello, World!")
```

```bash
pip install pytest-otel
```
````

**Tables**:
```markdown
| Header 1 | Header 2 | Header 3 |
|----------|----------|----------|
| Cell 1   | Cell 2   | Cell 3   |
| Cell 4   | Cell 5   | Cell 6   |

Left-aligned | Center-aligned | Right-aligned
:------------|:--------------:|--------------:
Left         | Center         | Right
```

**Blockquotes**:
```markdown
> This is a blockquote.
> It can span multiple lines.
>
> > Nested blockquote
```

**Horizontal Rules**:
```markdown
---
***
___
```

### Best Practices for Markdown

**1. Consistency**:
- Use consistent formatting throughout
- Choose one style for emphasis and stick with it
- Use consistent header capitalization
- Maintain consistent spacing

**2. Readability**:
- Add blank lines between sections
- Use blank lines around code blocks and lists
- Keep lines under 120 characters when possible
- Use meaningful link text (avoid "click here")

**3. Accessibility**:
- Provide alt text for all images
- Use descriptive link text
- Maintain proper header hierarchy
- Use semantic markup

**4. Code Examples**:
- Always specify language for syntax highlighting
- Keep examples concise and focused
- Ensure code examples are correct and runnable
- Include output or expected results when relevant

**5. Links**:
- Use relative links for internal documentation
- Check that all links work
- Use reference-style links for repeated URLs
- Include link titles for additional context

**6. Documentation Structure**:
```markdown
# Document Title

Brief introduction explaining what this document covers.

## Table of Contents

- [Section 1](#section-1)
- [Section 2](#section-2)
- [Section 3](#section-3)

## Section 1

Content for section 1...

## Section 2

Content for section 2...

## Section 3

Content for section 3...

## Additional Resources

- [External resource 1](https://example.com)
- [External resource 2](https://example.com)

## Related Documentation

- [Related doc 1](./related-doc-1.md)
- [Related doc 2](./related-doc-2.md)
```

### Markdown Linting

**Use markdown linters** to maintain quality:
- Configure markdownlint or similar tools
- Define rules in `.markdownlint.json` or `.markdownlintrc`
- Integrate linting into CI/CD pipeline
- Fix linting issues before merging

**Example configuration**:
```json
{
  "default": true,
  "MD013": {
    "line_length": 120,
    "code_blocks": false,
    "tables": false
  },
  "MD033": false,
  "MD041": false
}
```

## Summary

This agent enforces:
1. **KISS**: Simple, maintainable solutions
2. **SOLID**: Proper object-oriented design
3. **DRY**: No code duplication
4. **YAGNI**: Only implement what's needed
5. **TDA**: Encapsulate behavior with data
6. **Python Best Practices**: Type hints, docstrings, modern features
7. **Documentation**: Treat as code, keep current, explain why
8. **Markdown**: Consistent, readable, accessible documentation

Always apply these principles to create high-quality, maintainable code and documentation.
